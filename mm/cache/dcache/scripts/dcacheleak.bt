#!/usr/bin/bpftrace --unsafe
/**
 * File: dcacheleak.bt 
 *
 * Description: Check dentry slab memory leak
 *
 * Author: Rong Tao <rongtao@cestc.cn>
 * Data: 2022-04-22
 *
 * How to test:
 * -------------------------------------------------
 * 1. Drop dcaches first, to make ALLOC & FREE even:
 *  $ while :; do sudo sh -c "echo 2 > /proc/sys/vm/drop_caches"; done
 *
 * 2. Execute dcacheleak.bt
 *  $ sudo ./dcacheleak.bt
 *
 * 3. Genrate negative dentry,
 *    It's should be "-bash: cd: /tmp/rongtaoj7p: No such file or directory"
 *  $ while :; do cd `mktemp -u /tmp/rongtaoXXX` 2>/dev/null; done
 *
 * PS:
 *  kmem_cache_alloc() maybe use "kmalloc-192" slab, see
 *  $ sudo cat /sys/kernel/slab/dentry/object_size
 *  192
 */
#include <linux/slab.h>
#include <linux/dcache.h>

BEGIN
{
	printf("Tracing dcache leak. press ctrl-c to end.\n");
}

kprobe:__d_alloc
{
	@d_alloc_flag[pid] = 1;
}

kretprobe:__d_alloc
{
	if (retval) {
		@dcount["   ALLOC"] = count();
		$dentry = (struct dentry *)retval;
		@lockref_count["    ALLOC"] = hist($dentry->d_lockref.count);
	} else {
		@dcount[" x ALLOC"] = count();
	}
	@d_alloc_flag[pid] = 0;
}

kprobe:__d_free,
kprobe:__d_free_external
{
	@d_free_flag[pid] = 1;
}

kretprobe:__d_free,
kretprobe:__d_free_external
{
	@d_free_flag[pid] = 0;
}

kprobe:kmem_cache_free
/@d_alloc_flag[pid] == 1 || @d_free_flag[pid] == 1/
{
	if (@d_alloc_flag[pid] == 1) {
		/* Called in __d_alloc */
		@dcount[" x ALLOC"] = count();
	}
	if (@d_free_flag[pid] == 1) {
		/* Called in __d_free/__d_free_external */
		@dcount["    FREE"] = count();
	}
}

kprobe:d_lru_add,
kprobe:d_shrink_add
{
	$dentry = (struct dentry *)arg0;
	@lockref_count[" LRU_ADD"] = hist($dentry->d_lockref.count);
	@dcount[" LRU_ADD"] = count();
}

kprobe:d_lru_del,
kprobe:d_shrink_del
{
	$dentry = (struct dentry *)arg0;
	@lockref_count[" LRU_DEL"] = hist($dentry->d_lockref.count);
	@dcount[" LRU_DEL"] = count();
}

kprobe:__d_rehash
{
	$dentry = (struct dentry *)arg0;
	@lockref_count["HASH_ADD"] = hist($dentry->d_lockref.count);
	@dcount["HASH_ADD"] = count();
}

/**
 * ERROR in Ubuntu 20.04.4 LTS
 * https://github.com/iovisor/bpftrace/issues/2199
 */
kprobe:__d_instantiate_anon
{
	$disconnected = arg2;

	if (!$disconnected) {
		@dcount["HASH_ADD"] = count();
	}
}

kprobe:___d_drop
{
	$dentry = (struct dentry *)arg0;
	@lockref_count["HASH_DEL"] = hist($dentry->d_lockref.count);
	@dcount["HASH_DEL"] = count();
}

interval:s:1
{
	system("clear");
	system("echo /proc/sys/fs/dentry-state");
	system("cat /proc/sys/fs/dentry-state");
	print(@dcount);
	print(@lockref_count);
}

END
{
	clear(@dcount);
	clear(@d_alloc_flag);
	clear(@d_free_flag);
	printf("Bye.\n");
}
